% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/block.R
\name{block}
\alias{block}
\title{block}
\usage{
block(dfA, dfB, cols.exact = NULL, cols.numeric = NULL,
  numeric.range = NULL, cols.encoder = NULL,
  encoder.model.path = NULL, encoder.trainA = NULL,
  encoder.trainB = NULL, encoder.block.method = "binary",
  encoder.nclusters = 5, encoder.maxiter = 1000,
  known.matches = NULL, dim.latent = 8, dim.encode = 64,
  dim.decode = 64, max.length = 12, num.encode.layers = 2,
  num.decode.layers = 2, batch.size = 32, epochs = 500, lr = 5e-04,
  validation.split = 0.2, save.dir = "~/blocking_models/",
  reconstruct = TRUE, reconstruct.n = 5, reconstruct.display = 20,
  earlystop = FALSE, earlystop.patience = 10, tensorboard = FALSE,
  tensorboard.runid = as.character(Sys.time()), verbose = 2,
  n.cores = parallel::detectCores() - 1)
}
\arguments{
\item{dfA}{Dataframe to be linked to \code{dfB}}

\item{dfB}{Dataframe to be linked to \code{dfA}, if doing deduplication this is \code{dfA}}

\item{cols.exact}{List of exact match columns}

\item{cols.numeric}{List of numeric range columns}

\item{numeric.range}{Range of numeric}

\item{cols.encoder}{List of encoder columns}

\item{encoder.model.path}{Path to encoder model}

\item{encoder.trainA}{Vector of names to train}

\item{encoder.trainB}{Vector of matching names to train}

\item{encoder.block.method}{binary or cluster}

\item{encoder.nclusters}{Number of cluster is encoding by cluster}

\item{encoder.maxiter}{Max iterations in kmeans clustering}

\item{known.matches}{Dataframe of known matches with first column having indices of matches 
from dfA and second column having indices of known matches from dfB}

\item{dim.latent}{Number of latent dimensions}

\item{dim.encode}{Number of encoding dimensions}

\item{dim.decode}{Number of decoding dimensions}

\item{max.length}{Maximum length of characters}

\item{num.encode.layers}{Encode layers}

\item{num.decode.layers}{Decoder layers}

\item{batch.size}{Training batch size}

\item{epochs}{Number of training epochs}

\item{lr}{Learning rate}

\item{validation.split}{Validation}

\item{save.dir}{save directory path}

\item{reconstruct}{Whether or not show reconstructions}

\item{reconstruct.n}{How many reconstructions to show}

\item{reconstruct.display}{After many epochs to show reconstructions}

\item{earlystop}{TRUE if stopping early when validation loss is no longer decreasing,
if FALSE then train for all epochs}

\item{earlystop.patience}{Number of epochs to wait while validation loss does not
decrease before stopping training early}

\item{tensorboard}{TRUE if tensorboard metrics are to be recorded. 
Logs are recorded in the /tmp/ directory}

\item{tensorboard.runid}{Unique identifier for the run to separate tensorboard logs}

\item{verbose}{Verbosity level for training output, 0 = silence, 1 = minimal, 2 = verboses}

\item{n.cores}{cores to parallelize over}
}
\value{
blocklist object with 7 values 
\item{dfA}{dataframeA with encoded vectors appended}
\item{dfB}{dataframeB with encoded vectors appended}
\item{blocks}{data.table with each row representing one pair of records} 
\item{block.metrics}{Metrics on block quality}
\item{encoder}{encoder model if encoder was used}
\item{encoded.A}{matrix of encoded values from dataframeA}
\item{encoded.B}{matrix of encoded values from dataframeB}
}
\description{
Calculates cartesian product of records in two dataframes and filters out pairs which are 
unlikely to be matches. Blocks can be formed by comparing exact values, comparing values which are 
with a range of each other, and string comparisons using vector encodings. Encoded vectors can be 
blocked using the binary method or by clustering encoded vectors.
}
